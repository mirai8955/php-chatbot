# コードスタイル抽出の方法論

## 1. 抽出の基本原則

### 1.1 目的の明確化

コードスタイル抽出の目的は、**新しいメンバーがプロジェクトに馴染むために必要な「暗黙知」を形式知化すること**です。

抽出すべきは：
- ✅ プロジェクト固有の慣習とパターン
- ✅ 繰り返し現れる設計の決定
- ✅ 明文化されていない「お約束」
- ✅ コードの背後にある意図や哲学
- ❌ 一度しか使われていない特殊ケース
- ❌ 一般的なPHPの構文規則（すでに文書化されているもの）

### 1.2 抽出の3つの柱

#### a) 統計的分析（定量的）
コードベース全体を数値的に分析し、パターンの頻度や傾向を把握

#### b) パターン認識（定性的）
繰り返し現れる設計パターンやイディオムを識別

#### c) コンテキスト理解（意味的）
なぜそのスタイルが採用されているのか、背景や意図を推測

## 2. 多層的抽出アプローチ

コードスタイルは単一の観点では捉えきれません。以下の4つの層で分析します。

### レイヤー1: ミクロレベル（構文・記法）

**対象**: 個々のコード行やステートメント

**抽出項目**:
- 命名規則（変数、関数、クラス、定数）
- インデント方式（スペースorタブ、幅）
- 括弧の配置（same-line vs next-line）
- 文字列リテラルの好み（シングル vs ダブルクォート）
- 配列記法（`array()` vs `[]`）
- 型宣言の使用（strict_types、戻り値型、プロパティ型）
- docblockの書き方とカバレッジ
- 空白行の使い方（論理的区切り）

**抽出方法**:
```
1. 全PHPファイルをパース（PHP-Parser使用推奨）
2. AST（抽象構文木）から以下を集計:
   - 命名パターン（正規表現でcamelCase/snake_case/PascalCase判定）
   - インデントトークンの分析
   - 括弧位置の統計
   - 型宣言の使用率
3. 頻度が80%以上のパターンを「プロジェクト標準」として抽出
4. 例外ケースも記録（古いコードなど）
```

**実装例**:
```php
// Micro-level extractor
class MicroLevelAnalyzer {
    public function analyzeNamingConventions(array $files): array {
        $patterns = [
            'class_names' => [],
            'method_names' => [],
            'variable_names' => [],
            'constant_names' => []
        ];
        
        foreach ($files as $file) {
            $ast = $this->parser->parse(file_get_contents($file));
            $visitor = new NamingPatternVisitor();
            $traverser = new NodeTraverser();
            $traverser->addVisitor($visitor);
            $traverser->traverse($ast);
            
            $patterns['class_names'][] = $visitor->getClassNamePatterns();
            // ... 他の要素も同様に収集
        }
        
        return $this->calculateDominantPatterns($patterns);
    }
}
```

### レイヤー2: メゾレベル（コンポーネント・メソッド設計）

**対象**: 関数、メソッド、クラスの構造

**抽出項目**:
- メソッドの平均長さと複雑度
- クラスの責務分離パターン
- コンストラクタのパターン（DI方式、ファクトリ使用など）
- エラーハンドリングの方針（例外 vs エラーコード）
- 引数の渡し方（配列 vs 個別パラメータ vs オプションオブジェクト）
- 戻り値のパターン（null許容、配列、オブジェクト）
- イミュータビリティへの姿勢
- staticメソッドの使用傾向
- トレイトの活用パターン

**抽出方法**:
```
1. 各クラス・メソッドの構造を分析
2. 以下の統計を収集:
   - メソッドあたりの行数分布
   - cyclomatic complexity の分布
   - 引数の数の分布
   - 依存性注入のパターン（constructor vs setter vs method）
3. 支配的なパターンを特定
4. 「良い例」となるコードを抽出（他のコードからも参照されているもの）
```

**分析観点**:
- **長さ**: メソッドは短く保つ傾向か、まとまった処理を書く傾向か
- **純粋性**: 副作用のない関数を好むか
- **命令型 vs 宣言型**: どちらのスタイルが多いか
- **継承 vs コンポジション**: どちらを選好するか

### レイヤー3: マクロレベル（アーキテクチャ）

**対象**: ファイル構成、ディレクトリ構造、モジュール間の関係

**抽出項目**:
- ディレクトリ構造の原則（レイヤードアーキテクチャ、ドメイン駆動設計など）
- ファイル命名規則
- 名前空間の使い方
- autoloadingの方式（PSR-4準拠など）
- 依存関係の方向性（上位→下位）
- インターフェースと実装の分離度
- 設計パターンの採用（Factory, Builder, Strategy, etc.）
- コンフィグの管理方法
- 環境変数の使い方

**抽出方法**:
```
1. ディレクトリ構造をツリー形式で可視化
2. composer.jsonから名前空間マッピングを抽出
3. 依存関係グラフを生成（nikic/php-parser + graph-tool）
4. 循環依存の検出
5. レイヤー違反の検出
6. 主要な設計パターンの使用箇所を特定
```

**重要な質問**:
- ビジネスロジックはどこに配置されるか？
- データアクセス層はどう抽象化されているか？
- 横断的関心事（ログ、認証）はどう扱われているか？
- テストコードはどこに配置され、どういう方針か？

### レイヤー4: メタレベル（哲学・価値観）

**対象**: プロジェクトの設計思想やトレードオフの判断基準

**抽出項目**:
- パフォーマンス vs 可読性（どちらを優先するか）
- 柔軟性 vs シンプルさ（どちらを優先するか）
- 明示性 vs 簡潔性（冗長でも明確 or DRY重視）
- 型安全性への姿勢（厳密 or 柔軟）
- 後方互換性の重要度
- ドキュメンテーション文化（コードで語る vs コメント重視）
- テストカバレッジへの姿勢

**抽出方法**:
```
1. READMEやCONTRIBUTING.mdから方針を読み取る
2. コミットメッセージから意思決定の背景を推測
3. 議論の多いPRやIssueを分析（あれば）
4. コード内のコメントで「なぜ」が説明されている箇所を集約
5. トレードオフが明示的に議論されている箇所を探す
```

**推論のヒント**:
- パフォーマンス最適化コードが多い → パフォーマンス重視
- 詳細なdocblockが全箇所にある → ドキュメント重視文化
- 型宣言が徹底されている → 型安全性重視
- 抽象化レイヤーが多い → 拡張性・柔軟性重視

## 3. 抽出プロセスの具体的ステップ

### ステップ1: 準備フェーズ

```
入力: プロジェクトのコードベース（Gitリポジトリ）

タスク:
1. リポジトリをクローン
2. 依存関係をインストール（composer install）
3. プロジェクト規模の把握
   - 総ファイル数
   - 総行数
   - クラス数
   - 主要な依存ライブラリ
4. ドキュメントの確認
   - README.md
   - CONTRIBUTING.md
   - .editorconfig
   - phpcs.xml / phpstan.neon など
```

### ステップ2: 自動分析フェーズ

```
ツール候補:
- PHP-Parser: ASTベースの構文解析
- PHPCS: コーディング規約チェック
- PHPStan/Psalm: 静的解析
- PHPLOC: メトリクス計測
- カスタムスクリプト: プロジェクト固有の分析

実行内容:
1. 全ファイルをパースしてASTを生成
2. 各レイヤーの抽出項目を集計
3. 統計情報を構造化データ（JSON/YAML）に保存
4. 典型例となるコードスニペットを抽出
```

### ステップ3: パターン認識フェーズ

```
AIによる分析:
1. 類似コード片のクラスタリング
2. 繰り返しパターンの検出
3. 命名の意味解析（単語の選び方の傾向）
4. コメントから意図を抽出
5. 「これは何のためのコードか」を分類

出力:
- 頻出パターン一覧
- パターンごとの具体例
- パターンの使用頻度
```

### ステップ4: 人間による検証・補完フェーズ

```
自動抽出には限界があるため、プロジェクトメンバーによるレビュー:

チェック項目:
☑ 抽出されたパターンは本当にプロジェクト標準か？
☑ 見逃されている重要な慣習はないか？
☑ 誤検出されたパターンはないか？
☑ 背景となる設計思想の理解は正しいか？

補完:
- 暗黙的なルールの明文化
- 歴史的経緯の補足
- 例外ケースの説明
```

### ステップ5: 構造化・文書化フェーズ

```
最終成果物の生成:

1. スタイルガイド文書（Markdown形式）
   - レベル別に整理
   - 例コードを豊富に含む
   - DO/DON'T形式で記載

2. 機械可読ルールセット（YAML/JSON）
   - 評価システムで使用可能な形式
   - パターンマッチング用の正規表現
   - AST構造のテンプレート

3. 例題テンプレート集
   - 各パターンを問題化したもの
   - 模範解答と解説
```

## 4. 抽出の質を高めるテクニック

### 4.1 頻度分析の重み付け

すべてのコードを同等に扱わない:

- **コアモジュール**: より重要（重み3倍）
- **テストコード**: 参考程度（重み0.5倍）
- **レガシーコード**: 参考程度（重み0.5倍）
- **最近のコミット**: より現在の方針を反映（重み2倍）

### 4.2 異常値の検出と除外

- 機械生成コード（マイグレーション、モックなど）は除外
- サードパーティコードの混入を除外
- 一回限りの実験的コードは除外

### 4.3 時系列分析

プロジェクトの成熟度に応じてスタイルは進化する:

```
初期（~v1.0）: 迅速な開発、柔軟性重視
中期（v1.x~v2.x）: リファクタリング、パターン固まる
後期（v3.x~）: 安定、後方互換性重視
```

→ 最新のスタイルを基準にしつつ、歴史も理解する

### 4.4 ドメイン知識の統合

コード単体では分からない文脈を補完:

- プロジェクトのドメイン（Web API、CLI、ライブラリなど）
- 対象ユーザー（開発者向け、エンドユーザー向け）
- 制約条件（PHP version、パフォーマンス要件）

## 5. 抽出結果の評価方法

### 5.1 精度の検証

**方法1: サンプルテスト**
- プロジェクトメンバーに10個のコードスニペットを見せる
- 「これはプロジェクトのスタイルに合っているか？」を判定
- 抽出したルールとメンバーの判断の一致率を測定

**方法2: 既存コードスコアリング**
- 抽出したルールで既存コードを評価
- 実際に良いとされているコード（よく参照される、最近書かれた）が高得点になるか確認

### 5.2 網羅性の検証

- 新メンバーへのヒアリング: 「分かりにくかった慣習」が抽出されているか
- コードレビューコメントの分析: よく指摘される項目が含まれているか

### 5.3 実用性の検証

- 抽出したスタイルガイドで実際に問題を作成
- プロジェクトメンバーに解いてもらう
- 「これを学べば確かにプロジェクトに馴染める」と感じてもらえるか

## 6. 継続的な更新

スタイルは進化するため、定期的な再抽出が必要:

```
トリガー:
- メジャーバージョンアップ
- 大規模リファクタリング
- コーディング規約の変更
- 四半期に1回など定期的に

差分検出:
- 前回の抽出結果との diff
- 新たに追加されたパターン
- 廃止されたパターン
```

## まとめ

効果的なコードスタイル抽出には:

1. ✅ **多層的なアプローチ**: ミクロからマクロまで
2. ✅ **定量と定性のバランス**: 統計だけでなく意味も理解
3. ✅ **自動化と人間の判断の組み合わせ**: 機械の正確さと人間の洞察
4. ✅ **コンテキストの重視**: なぜそのスタイルか
5. ✅ **継続的な改善**: 一度きりではなく進化させる

次のステップ: [02_style_dimensions.md](./02_style_dimensions.md)で、各レイヤーの詳細な抽出項目を見ていきます。

