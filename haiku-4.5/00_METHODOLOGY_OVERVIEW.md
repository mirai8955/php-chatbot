# PHPコードベース コーディングスタイル抽出方法論

## 概要

このドキュメントは、任意のPHPプロジェクトから、そのコーディングスタイルとパターンを体系的に抽出するための方法論を提示します。

**目的**：
- チーム固有のコーディング慣習を可視化
- 問題出題時の「正解例」の根拠を明確にする
- 解答評価時の「ガイドライン準拠度」を客観的に判定する
- ユーザーが素早くプロジェクトのスタイルに適応できるようにする

**重要な考え方**：
> 「推奨されるべきスタイル」ではなく、「実際に使われているスタイル」を抽出する

---

## 抽出の3つの階層構造

コーディングスタイルは以下の3つの階層で理解する必要があります：

### 1. **マクロレベル** - アーキテクチャ・構成

「プロジェクト全体で、どのように整理されているか」

- ディレクトリ構造とモジュール分割方針
- ファイル命名規則
- クラス・インターフェースの設計パターン
- 依存関係の流れ（DI、サービスロケーター、など）
- エラーハンドリングの全体方針

**例**：
```
src/
  Handler/         ← ハンドラーパターン
  Exception/       ← 例外クラスの集約
  Middleware.php   ← ミドルウェアのシングルエントリ
```

### 2. **ミッドレベル** - 関数・クラス・メソッド設計

「個々のコンポーネント内で、どのように実装されているか」

- メソッドの責任分離方針
- パラメータの設計パターン
- 戻り値の設計（配列 vs オブジェクト vs Union型など）
- コンストラクタの設計（プロパティ昇格 vs 手動アサイン）
- アクセス修飾子の使い分け
- 型ヒントの活用度

**例**：
```php
// パターン例：ビルダーパターンの活用度、チェーンメソッドの使用
$client->setOption('timeout', 30)
        ->setOption('ssl_verify', true)
        ->request('GET', $url);
```

### 3. **マイクロレベル** - 行レベルのコード表現

「実装の詳細、キーボード入力レベルでの一貫性」

- インデント（スペース数）
- ブレースの位置（K&R style vs Allman style）
- スペーシング（演算子の前後、カンマの後ろ）
- 1行の長さ制限
- コメント・ドキュメンテーションの形式
- 文字列のクォート使い分け（シングル vs ダブル）

**例**：
```php
// パターン例：カンマの後ろにスペース、演算子前後にスペース
$result = someFunction($param1, $param2, $param3);
if ($condition && $otherCondition) {
    // インデント4スペース
}
```

---

## 抽出プロセスの全体フロー

```
┌─────────────────────────────────────┐
│   対象プロジェクトのコード分析      │
└──────────────┬──────────────────────┘
               │
       ┌───────┴───────┐
       │               │
       ▼               ▼
   マクロレベル   ミッドレベル
   抽出ツール      抽出ツール
       │               │
       └───────┬───────┘
               │
               ▼
       ┌──────────────────┐
       │ マイクロレベル   │
       │ 抽出ツール       │
       └────────┬─────────┘
                │
       ┌────────┴─────────┐
       │                  │
       ▼                  ▼
   スタイル構成   学習ルール生成
   ドキュメント
       │                  │
       └────────┬─────────┘
                │
                ▼
        ┌──────────────────┐
        │ 問題出題・評価   │
        │ フレームワーク   │
        └──────────────────┘
```

---

## 具体的な抽出方法の3つのアプローチ

### アプローチ1: 統計分析ベース

**対象**：マイクロレベル

実装の詳細（インデント、括弧の位置、スペーシングなど）を統計的に分析

- ファイルを複数サンプリング
- 各要素の出現パターンを集計
- 最頻値と例外を記録

**利点**：客観的、自動化しやすい
**欠点**：「なぜこのスタイルなのか」という理由が分からない

### アプローチ2: パターンマッチング・分類ベース

**対象**：ミッドレベル～マクロレベル

既知のデザインパターンと照らし合わせて分類

- クラス設計の「このプロジェクトでの書き方」を分類
- メソッドの「このプロジェクトでの責任分離」を把握
- エラーハンドリングの「このプロジェクトでの流儀」を学習

**利点**：実装パターンの「なぜ」が理解できる
**欠点**：手作業が多い、AI判定が難しい場合もある

### アプローチ3: AST（抽象構文木）解析ベース

**対象**：ミッドレベル～マクロレベル

PHPの抽象構文木をパース、プログラムの構造を深く理解

- クラス構造、メソッド定義、制御フローを抽象化
- 各要素の関係性を詳細に把握
- 正規化した表現で比較

**利点**：最も詳細で正確
**欠点**：実装が複雑、処理時間がかかる

---

## 推奨される統合的アプローチ

最も効果的なのは、**3つのアプローチを組み合わせる**ことです：

1. **第1段階**：AST解析で、プロジェクトの構造的特徴を把握
2. **第2段階**：パターンマッチングで、設計的特徴を分類
3. **第3段階**：統計分析で、マイクロレベルの詳細を確定

---

## 抽出成果物の形式

抽出完了後、以下の形式でスタイルを保存：

```yaml
# style_profile.yaml
project_name: "Guzzle"
php_version: "7.4+"

macro_level:
  directory_structure:
    - pattern: "src/Handler/*"
      purpose: "HTTP処理の役割分離"
    - pattern: "src/Exception/*"
      purpose: "例外の集約"
  
  class_design:
    - pattern: "Interface + Implementation"
      frequency: 90%
    - pattern: "Trait for shared behavior"
      frequency: 70%

mid_level:
  method_design:
    - method_size: "平均15行"
    - parameter_type_hints: "80% 採用"
    - return_type_hints: "75% 採用"
  
  parameter_patterns:
    - pattern: "Options array pattern"
      frequency: 60%
    - pattern: "Builder pattern"
      frequency: 40%

micro_level:
  indentation: "4 spaces"
  brace_style: "K&R"
  line_length: "120 characters"
  quote_preference: "double quotes for interpolation, single otherwise"
```

---

## 次のステップ

このアプローチに基づいて：

1. **多層的抽出フレームワーク** → `01_MULTILAYER_EXTRACTION_FRAMEWORK.md`
2. **実装手順・ツール** → `02_IMPLEMENTATION_GUIDE.md`
3. **問題出題・評価への応用** → `03_APPLICATION_TO_QUESTIONS.md`
4. **実装例** → `examples/` フォルダ

を順次作成します。
